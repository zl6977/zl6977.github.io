<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2022-04 on ZZZ's Blogs</title><link>https://zl6977.github.io/tags/2022-04/</link><description>Recent content in 2022-04 on ZZZ's Blogs</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 25 Apr 2022 15:46:00 +0000</lastBuildDate><atom:link href="https://zl6977.github.io/tags/2022-04/index.xml" rel="self" type="application/rss+xml"/><item><title>pipe router optimization</title><link>https://zl6977.github.io/obsidian/pipe-router-optimization/</link><pubDate>Mon, 25 Apr 2022 15:46:00 +0000</pubDate><guid>https://zl6977.github.io/obsidian/pipe-router-optimization/</guid><description>Initialize_points() is time-consuming 3 ways to try:
tags and points are different. initialize tags, not points. hard to know when obstacle list is changed. -&amp;gt; ==The caller should know.== do not use points, use if pt in obstacle_list to judge. which is faster? if pt in obstacle_list is slower, so it is not helpful. sometimes the ==goal point is also an obstacle point==, so this is not robust. neighbors[] should include goalPt + goalVec not goalPt How about only generate the points on the boundary of the equipment?</description></item><item><title>C++笔记</title><link>https://zl6977.github.io/obsidian/c-%E7%AC%94%E8%AE%B0/</link><pubDate>Thu, 07 Apr 2022 12:11:00 +0200</pubDate><guid>https://zl6977.github.io/obsidian/c-%E7%AC%94%E8%AE%B0/</guid><description>#程序员
Essential C++ #someday ✅ 2022-04-18 1 编程基础 很快就看完了，其中的文件操作不是很熟练，但应该不难。
2 面向过程的编程风格。 指针(pointer)与引用(reference) pointer参数和reference参数二者之间功能类似，用法略有不同，更重要的差异是：
pointer 可能为空，不指向实际对象。当我们提领pointer时，一定要先确定其值并非为0。 而对于reference，其必然指向某个对象，所以不须做此检查。 若需要更改原变量，需要传址，以下两者皆可： function(int&amp;amp; inPara); function(int* inParaPt); 若不需要更改原变量，只需传值，以下两者皆可： function(int inPara); function(const int&amp;amp; inPara); //此方法不需要在内存中复制一份原变量。
如果是内建变量，因为内存占用很少，两者皆可。 如果是自定义类，一般用后者，省时省空间。 内存管理 file extent. This is not a good choice in most cases. local scope dynamic extent new, delete exist in heap memory if not deleted, ==memory leak== happens. 动静态内存分配 //见bilibili收藏 //静态内存分配，在stack，由编译器自动分配内存，生命周期结束自动释放 int i = 10; //动态内存分配，在heap，如果不delete会造成内存溢出 int *j = new int(20); delete j; 静态局部对象 local static objects 只对该函数可见的静态变量。 可以避免一些重复计算。</description></item><item><title>KBE framework to design an engineering product</title><link>https://zl6977.github.io/obsidian/kbe-framework-to-design-an-engineering-product/</link><pubDate>Mon, 04 Apr 2022 16:32:00 +0200</pubDate><guid>https://zl6977.github.io/obsidian/kbe-framework-to-design-an-engineering-product/</guid><description>#KBE
framework in KBE approach the problems identification -&amp;gt; steps to solve the problems -&amp;gt; tools/method can be used
possible objectives model represetation: geometric model non-geometric parameters CAD model CAE model ==rule represetation:== the rules/functions in &amp;ldquo;steps&amp;rdquo; steps: analysis algorithm optimization algorithm data storage and retrieve software integration report generation supporting tech KBE app as a ==web application architecture==. database application server user interface: http server KBE app as a ==&amp;ldquo;single big program&amp;rdquo;==, there should be data structure (the parametric model); parameters + constructor -&amp;gt; a sharable format function declarations: sth.</description></item></channel></rss>